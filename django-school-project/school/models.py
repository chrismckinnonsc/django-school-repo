from django.db import models
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from django.db.models.query import QuerySet
from django.db.models import Q
import datetime
import inspect
import os

try:
    import badger
    from badger import Badge
except ImportError:
    badger = False


HOUSES = (("BLACKBURN","Blackburn"),("DOHERTY", "Doherty"),("FLANNERY","Flannery"),("WOOD","Wood"))

class AuthUserManager(BaseUserManager):
    def create_user(self, email, password=None):
        if not email:
            raise ValueError('Users must have an email address')

        user = self.model(
            email=AuthUserManager.normalize_email(email),
            )

        user.set_password(password)
        user.save(using=self._db)
        return user

    def __getattr__(self, attr, *args):
        try:
            return getattr(self.__class__, attr, *args)
        except AttributeError:
            return getattr(self.get_query_set(), attr, *args)

    def get_query_set(self):
        return MyQuerySet(self.model)


class MyQuerySet(QuerySet):
    def filter(self, *args, **kwargs):
        if 'username' in kwargs:
            kwargs.update({'email': kwargs.pop('username')})
        return super(MyQuerySet, self).filter(*args, **kwargs)


class AuthUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(verbose_name='Email address', max_length=255, unique=True, db_index=True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    def get_profile(self):
        for related in self._meta.get_all_related_objects():
            if related.model.__base__.__name__ == 'SchoolPerson': #TODO - might we have non-SchoolPerson profiles?
                try:
                    return getattr(self, related.get_accessor_name())
                except ObjectDoesNotExist:
                    pass
        raise ObjectDoesNotExist

    def get_username(self):
        return self.email

    def get_full_name(self):
        p = self.get_profile()
        return ("%s %s" % (p.first_name, p.last_name))

    def get_short_name(self):
        p = self.get_profile()
        return p.first_name

    objects = AuthUserManager()

    USERNAME_FIELD = 'email'
    #TODO - do we need to do anything with the linked Student/StaffMember object if the email is changed here?


class GoogleAccountMixin(models.Model):
    # ID code that references google account; this is generated by google and is not the email address
    google_id = models.CharField('Google ID', max_length=30, blank=True)
    google_last_update = models.DateTimeField('Google account last updated', blank=True, null=True)

    class Meta:
        abstract = True


class SchoolPerson(GoogleAccountMixin, models.Model):
    '''Abstract person class - used currently as base class for student and teacher classes'''

    GENDERS = (("F","Female"),("M","Male"))
    TITLES = (("Mr","Mr"),("Ms","Ms"),("Mrs","Mrs"),("Miss","Miss"),("Dr","Dr"))

    auth = models.OneToOneField(settings.AUTH_USER_MODEL, blank=True, null=True)  # user for auth purposes

    first_name = models.CharField('First Name', max_length=30, blank=True)
    last_name = models.CharField('Last Name', max_length=30, blank=True)
    email = models.EmailField('Email Address', unique=True)

    middle_name = models.CharField('Middle Name', max_length=100, blank=True)
    preferred_name = models.CharField('Preferred Name', max_length=100, blank=True)
    title = models.CharField(max_length=10,choices=TITLES, blank=True)
    date_of_birth = models.DateField('Date of Birth')
    gender = models.CharField(max_length=1,choices=GENDERS, blank=True)

    timetable_id = models.CharField('CASES Code', max_length=10, unique=True)
    network_id = models.CharField('Authcate ID', max_length=20, unique=True, null=True)
    card_id = models.CharField('Card number', max_length=20, unique=True, null=True)
    initial_password = models.CharField('Initial Password', max_length=20, blank=True)

    is_current = models.BooleanField(default=True)
    start_date = models.DateField('Start Date',blank=True, null=True)
    end_date = models.DateField('End Date',blank=True, null=True)
    house_group = models.CharField(max_length=20, choices=HOUSES, blank=True)
    mentor_group = models.CharField("Mentor Group", max_length=20, blank=True)

    address1 = models.CharField(max_length=50, blank=True)
    address2 = models.CharField(max_length=50, blank=True)
    address3 = models.CharField(max_length=50, blank=True)
    post_code = models.CharField(max_length=10, blank=True)
    state = models.CharField(max_length=20, blank=True, default="Victoria")
    country = models.CharField(max_length=20, blank=True, default="Australia")
    home_number = models.CharField(max_length=30,blank=True)
    mobile_number = models.CharField(max_length=30,blank=True)
    initial_password = models.CharField(max_length=50,blank=True)

    rs_mis_id = models.CharField(max_length=30, blank=True)

    def __unicode__(self):
        return self.timetable_id

    def save(self, *args, **kwargs):
        # called via import script; can use to trigger or prevent triggering certain actions
        #if os.path.basename(inspect.stack()[1]) == 'import_data.py':
        #    pass

        #TODO - trigger creation/deactivation of google accounts? Other sync?
        if self.pk is None:  # Newly created account
            (self.auth, created) = AuthUser.objects.get_or_create(email=self.email)
            if not self.network_id:
                self.network_id = self.timetable_id
            if not self.card_id:
                self.card_id = self.timetable_id
        else:  # account already exists; check if email has changed
            if self.auth.email != self.email:
                (self.auth, created) = AuthUser.objects.get_or_create(email=self.email)

            #TODO - test this works as expected
            # check if timetable code has changed; if so we need to update a heap of stuff
            #orig = self.__class__.objects.get(pk=self.pk)
            #if orig.timetable_id != self.timetable_id:
        super(SchoolPerson, self).save(*args, **kwargs)

    class Meta:
        abstract = True
        ordering = ['timetable_id']


class Student(SchoolPerson):
    STUDENT_TYPES = (("STU","Regular Student"),("EXC", "Exchange Student"))
    year_level = models.CharField(max_length=3) #TODO - need way to auto-increment?
    govt_student_code = models.CharField("Victorian Student Number",max_length=20, blank=True)
    govt_email_address = models.EmailField(blank=True)
    uni_application_code = models.CharField("VTAC Number",max_length=20, blank=True)
    student_type = models.CharField(max_length=10, choices=STUDENT_TYPES)


class StaffMember(SchoolPerson):
    STAFF_TYPES = (("TEA","Teacher"),("ESS","Education Support"), ("EXT","External"), ("PRE","Pre-Service Teacher"))
    govt_id_number = models.CharField("DEECD ID",max_length=20,blank=True)
    govt_email_address = models.EmailField(blank=True)
    staff_type = models.CharField(max_length=10, choices=STAFF_TYPES)
    work_phone_number = models.CharField(max_length=30,blank=True)
    location = models.ForeignKey('Location', blank=True, null=True)

class AbstractCycle(models.Model):
    number = models.PositiveSmallIntegerField()
    year = models.CharField(max_length=4)
    start_date = models.DateField()
    end_date = models.DateField()

    class Meta:
        abstract = True
        unique_together = ('year', 'number')

    def __unicode__(self):
        return "%s: %s" % (self.year, self.number)

    @classmethod
    def current(cls):
        cycles = cls.objects.filter(start_date__lte=datetime.date.today(), end_date__gte=datetime.date.today())
        if len(cycles) == 0:
            return cls.objects.latest('pk') #no match, so we'll use the most recently created cycle
        elif len(cycles) == 1:
            return cycles[0]
        else:
            return cycles[0] #TODO - what if there is more than one cycle matching?

    @classmethod
    def working(cls, request=False): #TODO - need to be able to change this somewhere
        working_param = 'working_%s' % cls.__name__.lower()
        if not request:
            return cls.current()
        if not request.session.get(working_param, False):
            request.session[working_param] = cls.current()
        return request.session[working_param]


class Semester(AbstractCycle):
    pass

class Location(models.Model):
    code = models.CharField(max_length=20, unique=True)
    description = models.CharField(max_length=200, blank=True)
    #TODO: geo-coordinates?
    class Meta:
        ordering = ['code']


class Department(models.Model):
    name = models.CharField(max_length=100)
    leaders = models.ManyToManyField(StaffMember, related_name='leader', blank=True, null=True)
    members = models.ManyToManyField(StaffMember, related_name='member', blank=True, null=True)
    #TODO - way to get all members (both explicit via members field above, and via class enrolment below)

    def teachers(self, request):
        '''Gets teachers currently teaching in this dept (via class via subject)'''
        current_classes = SchoolClass.objects.filter(cycle=Semester.working(request), subject__faculty=self)
        return StaffMember.objects.filter(is_current=True, schoolclass__in=current_classes).distinct()

    #TODO - add subject leaders? Or can assume they teach as well?
    def all_members(self, request):
        '''Gets all members - leaders, assigned members, and teachers currently teaching subjects in this dept'''
        current_classes = SchoolClass.objects.filter(cycle=Semester.working(request), subject__faculty=self)
        return StaffMember.objects.filter(Q(schoolclass__in=current_classes) | Q(member=self) | Q(leader=self),
                                          is_current=True).distinct()

    class Meta:
        ordering = ['name']

    def __unicode__(self):
        return self.name


class Subject(models.Model):
    '''A subject - subjects have one or more classes, which contain enrolments'''
    code = models.CharField(max_length=100, unique=True)
    name = models.CharField(max_length=100)
    faculty = models.ForeignKey(Department) #TODO - rename to department?
    leaders = models.ManyToManyField(StaffMember, blank=True, null=True) #TODO - should this be in a cycle?
    #TODO - method to get all teachers/students
    #TODO - add google group id BUT: how will we resolve year-based subject groups in google with perpetual groups here?
    if badger:
        badges = models.ManyToManyField(Badge, blank=True, null=True)

    def students(self, request):
        sem = Semester.working(request)
        return Student.objects.filter(is_current=True, schoolclass__subject=self, schoolclass__cycle=sem)

    def teachers(self, request):
        sem = Semester.working(request)
        return StaffMember.objects.filter(is_current=True, schoolclass__subject=self, schoolclass__cycle=sem)

    class Meta:
        ordering = ['code']

    def __unicode__(self):
        return "%s: %s" % (self.code, self.name)


class SchoolClass(models.Model):
    code = models.CharField(max_length=100)
    name = models.CharField(max_length=200)
    cycle = models.ForeignKey(Semester)
    students = models.ManyToManyField(Student, through='Enrolment', blank=True, null=True)
    teacher = models.ForeignKey(StaffMember)
    subject = models.ForeignKey(Subject)
    google_calendar_id = models.CharField(max_length=100, blank=True)
    #team_class = models.ManyToManyField('self', null=True, blank=True) #TODO

    def __unicode__(self):
        return "%s: %s" % (self.code, self.cycle)

    def save(self, *args, **kwargs):
        super(SchoolClass, self).save(*args, **kwargs)
        if not self.google_calendar_id:
            from sync import google_tasks
            google_tasks.google_task('google_create_cal_from_class', schoolclass=self)

    class Meta:
        verbose_name = 'Class'
        verbose_name_plural = 'Classes'
        unique_together = ('code', 'cycle')
        ordering = ['code']


class Enrolment(models.Model):
    '''Binds a student to a class/subject/group in a particular semester'''
    student = models.ForeignKey(Student)
    school_class = models.ForeignKey(SchoolClass)
    def __unicode__(self):
        return "%s %s" % (self.student, self.school_class)

